<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 技术 | I'm Ricky -- 个人主页]]></title>
  <link href="http://rickytan.cn/blog/categories/ji-zhu/atom.xml" rel="self"/>
  <link href="http://rickytan.cn/"/>
  <updated>2016-10-28T21:21:15+08:00</updated>
  <id>http://rickytan.cn/</id>
  <author>
    <name><![CDATA[Ricky]]></name>
    <email><![CDATA[ricky.tan.xin@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[XCode 中如何自动增长 Build 号]]></title>
    <link href="http://rickytan.cn/blog/2014/09/28/xcode-build-number/"/>
    <updated>2014-09-28T19:46:00+08:00</updated>
    <id>http://rickytan.cn/blog/2014/09/28/xcode-build-number</id>
    <content type="html"><![CDATA[<h2>iTunes Connect 新步骤</h2>

<p>随着 iOS8 的推出，苹果 itunes connect 中上传新应用多了一个新步骤：测试。</p>

<p>几个月前听闻 Apple 收购 <a href="https://testflightapp.com">TestFlight</a>，但一直没有看到任何变化，如今 TestFlight 已经集成到新应用的发布
、审核过程中了。打开 <a href="https://itunesconnect.apple.com">iTunesConnect</a>，可以看到在 <code>Versions</code> 旁边新
增了一个 <code>Prerelease</code> 标签页。原先通过 <code>XCode</code> 上传的应用会直接进入苹果的审核队列中，现在它会先出现
在这里，这里其实就是一个 <code>TestFlight</code> 的功能，你可以在 <strong><em>Users and Roles</em></strong> 中增加测试人员的 <em>Apple ID</em>，
然后在 <code>Prerelease</code> 下的 <code>Internal Testers</code> 中可以看到。每上传一个新的 <strong><em>Build</em></strong>，苹果会自动发邮件给
测试人员，测试人号点开邮件中的链接，在 <code>Safari</code> 中打开，然后 <code>Safari</code> 会打开设备上的 <code>Test Flight</code>，
开始自动下载应用进行测试。</p>

<!--more-->


<p>这样的好处很明显，正在进行测试的版本与正式上线的版本是完全一样的，因为原来我们要做测试可能测试版与正式
版使用了不同的签名证书，然后每次加新人又要添加设备 <code>UDID</code> 到 <strong><em>Provisioning Profile</em></strong> 等等。</p>

<p>测试通过之后，回到 <code>iTunesConnect</code> 中的 <code>Versions</code>，下拉找到 <code>Build</code>，选择刚刚测试好的 <strong><em>Build</em></strong> 号，
点 <code>Save</code>，然后就可以进入正常的审核队列了。</p>

<blockquote><p><strong><em>注意：</em></strong>测试功能只有使用苹果开发者网站最近生成的 <strong><em>Provisioning Profile</em></strong> 才能开启，而且会自
动加入，不要去 <strong><em>Entitlement</em></strong> 中勾选了。</p></blockquote>

<h2>Build 号</h2>

<p>在 <code>iOS</code> 应用的 <code>Info.plist</code> 中有两个版本号，即 <strong><em>Version</em></strong> 和 <strong><em>Build</em></strong>，对应键值为 <code>CFBundleShortVersionString</code> 和 <code>CFBundleVersion</code>。
一个是应用程序本身发布时的版本号，一个是表示这个发布版的二进制代码是第几次编译得到的。在 <strong><em>iOS8</em></strong>
之前由于苹果并没有约束这两者的关系，本人一般就把两个填一样的，如 <code>2.1.4</code> 等，也一直没出过问题，但是
最近由于苹果加入了测试功能，所有上传的 <strong><em>Build</em></strong> 都会保存，然后第一个因为某原因审核不过，再上传第
二个就出现了 <strong><em>Build</em></strong> 号冲突的问题。于是想到这才是 <strong><em>Build</em></strong> 的正确使用方法，它本应该是个整数，
在 <strong><em>Version</em></strong> 保持不变，<strong><em>Build</em></strong> 应该是要随着编译次数增长的！</p>

<h2>自动增长</h2>

<p>那么如何让 <strong><em>Build</em></strong> 号自动增加呢？很早前搜到过一段代码，现在可以用上了：</p>

<ol>
<li><p>在 <code>XCode</code> 中选中项目，打开 <code>Build Phases</code>，如下图：</p>

<p> <img src="/images/run-script.png" alt="RunScript" /></p></li>
<li><p>点 “+” 增加一个过程，选择“Run Script”，移到“Link Binary With Libraries”之后，并贴入以下代码：</p>

<p> {% codeblock lang:bash %}</p>

<h1>!/bin/bash</h1>

<p>buildNumber=$(/usr/libexec/PlistBuddy -c &ldquo;Print CFBundleVersion&rdquo; &ldquo;$INFOPLIST_FILE&rdquo;)
buildNumber=$(($buildNumber + 1))
/usr/libexec/PlistBuddy -c &ldquo;Set :CFBundleVersion $buildNumber&rdquo; &ldquo;$INFOPLIST_FILE&rdquo;
 {% endcodeblock %}</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 下如何复制一个视图（包括它的所有属性）]]></title>
    <link href="http://rickytan.cn/blog/2014/02/20/how-to-copy-a-view-and-its-all-attribute-in-ios/"/>
    <updated>2014-02-20T02:43:00+08:00</updated>
    <id>http://rickytan.cn/blog/2014/02/20/how-to-copy-a-view-and-its-all-attribute-in-ios</id>
    <content type="html"><![CDATA[<p>在某些效果中，我们需要在当前视图上创建一个新的、一样的视图，并且叠在老的上面，然后让新的视图移动、缩放，或什么的，这样做出来的动画看起来比较流畅。对于简单的界面，我们可能按原有的样子生成一个新的就好，有没有更好更通用的办法呢？</p>

<h1>NSCoding</h1>

<p><code>UIView</code>无法通过<code>copy</code>方法来创建一个副本，这个想必大家都已经试过了。事实上，<code>UIView</code>是服从<NSCoding>协议的，这样它才能从<code>Xib</code>中反序列化出来，而我们最常用的一个序列化类就是<code>NSKeyedArchiver</code>。</p>

<!--more-->


<p>所以创建一个视图的副本可以这样：</p>

<p>{% codeblock lang:objc %}
UIView <em>view = &hellip;;
UIView </em>copy_view = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:view]];</p>

<p>{% endcodeblock %}</p>

<p>这样，视图中所有能通过<code>Xib</code>设置的属性（底色、字体、Frame等）全部复制到新的视图上了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 下如何设置全局字体？]]></title>
    <link href="http://rickytan.cn/blog/2014/02/20/global-font-of-ios/"/>
    <updated>2014-02-20T01:52:00+08:00</updated>
    <id>http://rickytan.cn/blog/2014/02/20/global-font-of-ios</id>
    <content type="html"><![CDATA[<h1>背景</h1>

<p><code>iOS 6</code>跟 <code>iOS 7</code>的字体还是有点不一样的，有时候为了两者的统一，或者，应设计师的要求，界面中所有的 Label，Button 等都用自定义字体，一般来说，我们在初始化的时候就需要不断地添加冗余的代码来设置自己的字体。</p>

<p>{% codeblock lang:objc %}
UILabel *label = [[UILabel alloc] init];
label.font = [UIFont fontWithName:@&ldquo;myFont&rdquo;];
&hellip;</p>

<p>{% endcodeblock %}</p>

<p>如果你的界面全部是代码实现的，而且项目初期就已经定下统一用什么字体了，这就不是什么难事。但是，试想，如果你的界面是由大量<code>IB</code>实现的，而且用的是自定义的字体，在<code>IB</code>中选都没法选；或是项目已经完成差不多了，上面要求统一改字体，那该如何是好？</p>

<!--more-->


<p>其实利用<code>objective-c</code>的动态性就可以轻松搞定。</p>

<h1>Method swizzling</h1>

<p>什么是<code>Method Swizzling</code>请<code>Google</code>之，这里只说明方法：</p>

<p><strong>注意：</strong> <em>以下方法只用于全局修改由 <code>Xib</code> 加载的界面的 UIButton, UILabel的字体，其他的如UITextField等类似，新建Catogery就好，想修改代码生成的界面，修改 initWithCoder 为 init就好</em></p>

<p>{% codeblock lang:objc %}</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<h1>import &lt;objc/runtime.h></h1>

<p>@interface UIButton (myFont) @end
@interface UILabel (myFont) @end</p>

<p>@implementation UIButton (myFont)</p>

<ul>
<li><p>(void)load
{
  Method imp = class_getInstanceMethod([self class], @selector(initWithCoder:));
  Method myImp = class_getInstanceMethod([self class], @selector(myInitWithCoder:));
  method_exchangeImplementations(imp, myImp);
}</p></li>
<li><p>(id)myInitWithCoder:(NSCoder*)aDecode
{
  [self myInitWithCoder:aDecode];
  if (self) {
      CGFloat fontSize = self.titleLabel.font.pointSize;
      self.titleLabel.font = &lt;# Your Font Here #>;
  }
  return self;
}</p></li>
</ul>


<p>@end</p>

<p>@implementation UILabel (myFont)</p>

<ul>
<li><p>(void)load
{
  Method imp = class_getInstanceMethod([self class], @selector(initWithCoder:));
  Method myImp = class_getInstanceMethod([self class], @selector(myInitWithCoder:));
  method_exchangeImplementations(imp, myImp);
}</p></li>
<li><p>(id)myInitWithCoder:(NSCoder*)aDecode
{
  [self myInitWithCoder:aDecode];
  if (self) {
      CGFloat fontSize = self.font.pointSize;
      self.font = &lt;# Your Font Here #>;
  }
  return self;
}</p></li>
</ul>


<p>@end</p>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[蛐蛐儿 SDK 破解]]></title>
    <link href="http://rickytan.cn/blog/2014/01/18/crack-xququer/"/>
    <updated>2014-01-18T15:23:00+08:00</updated>
    <id>http://rickytan.cn/blog/2014/01/18/crack-xququer</id>
    <content type="html"><![CDATA[<p><a href="http://xququ.com">蛐蛐儿</a> 是一套利用声音传输信息的解决方案，大家可能知道 <code>支付宝</code> 在早些时候就推出了当面付的功能，其实就是利用超声波将加密后的支付信息传输给附近的人。蛐蛐儿SDK可以在其官网上下载到，通过它的提供的Demo可以看出，它需要将一段任意字符串<em>S</em>上传它们的后台，然后生成一段16字节的<em>Token</em>，发送时只能发送此<em>Token</em>。同时，在接收方接收到<em>Token</em>后，需要访问它们的后台把原始字符串<em>S</em>下载下来。这个过程也正好解释了，为什么无论发送什么东西，声音长度是一致的，真正的数据并不是通过声音传的，而是通过网络下载的。</p>

<p>当然，其实大部分情况下这个过程已经够用了，因为开发者可以将自己需要传输的任何字符串编码为<em>Token</em>（这个字符串可以是<code>BASE64</code>编码，也可以是一个文件的下载链接），通过声音传输，然后再解码。</p>

<!--more-->


<p>{% codeblock viewcontroller.m lang:objc %}
&ndash; (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad];
[[XQuquerService defaultService] setDelegate:self];
[[XQuquerService defaultService] start];

NSString *str = ...;
[[XQuquerService defaultService] uploadData:str];
...
</code></pre>

<p>}</p>

<h1>prama mark XQuquer Delegate</h1>

<ul>
<li>(void)didSendDataToken
{</li>
</ul>


<p>}</p>

<ul>
<li>(void)didReceiveDataToken:(NSString *)dataToken
{
  &hellip;
}
{% endcodeblock %}</li>
</ul>


<p>但是如何我要传输的字符少于16位呢？这个过程似乎有点过了，于是我将<em>Token</em>改为任意一个我想要传输的字符串，发现没有声音了。原来这个<em>Token</em>并不是一个随机的值。原来我以为，SDK的后台就一张表，记录着<em>Token</em>和原始值的对应关系，而<em>Token</em>本身是随机的，或者就像短链接一样，将太长的内容变短而已。</p>

<p><em>Token</em>的生成引起了我的兴趣，于是我记下了一些能发送的<em>Token</em>，如：</p>

<pre><code>020240d3d0d42a48
</code></pre>

<p>改动任何字符均会导致没有声音，所以猜测这个<em>Token</em>本身带有验证机制。于是后来就跟踪到汇编代码想看看它的验证过程，这样我好自己生成<em>Token</em>。跟踪过程我就不细说了，反正中间出现过一段字符串：<strong>0003242ddd4082a4</strong>，我对照了一下，没有什么规律，然后又出现了<strong>0003242dddwuyifan</strong>，对比下SDK 的作者，正是 <strong>wu yifan</strong>，而这里他将后6位换成自己名字拼音做什么呢？</p>

<p>对于这两段 <em>Token</em> ：</p>

<pre><code>A = 020240d3d0d42a48
B = 0003242ddd4082a4
</code></pre>

<p>它们等长，同时 <em>A</em> 中出现过的字符 <em>B</em> 中也同样出现，并且词频是一样的！
在然后的几次单指令跟踪时，发现变量名中出过过 <code>dkey</code> 和 <code>ekey</code>，应该是 <code>decode</code> 和 <code>encode</code> ，检查内存，发现它们是 <code>int[16]</code> 的数组，这才发现 <em>A</em> 到 <em>B</em> 就是一个简单映射：</p>

<p>{% codeblock lang:c %}
const int dkey[] = {};</p>

<p>char A[16] = &ldquo;020240d3d0d42a48&rdquo;;
char B[17] = {0};
for (int i=0; i&lt;16; ++i) {</p>

<pre><code>B[i] = A[dkey[i]];
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>这个问题解决了，那作者自己的名字拼音是怎么回事呢？还有那段被替换的后6位？在后来的跟踪中，发现代码有调用 <code>MD5</code> ，参数是替换成名字拼音的字符！</p>

<pre><code>MD5("0003242dddwuyifan") = "4082a4f05d45574077b88a53965a7293"
</code></pre>

<p>这货的前6位，不就是 <em>B</em> 的后6位吗？到此， <em>Token</em> 的验证过程已经非常清楚了：</p>

<pre><code>Token = "...";              // 原始 Token
Token' = decode(Token);     // 用 dkey 解密的 Token
Prefix = Token'[0, 10];     // 前 10 位
Subfix = Token'[10, 6];     // 后 6 位

if (Subfix == MD5(Prefix + "wuyifan")[0, 6])
    return TRUE;
return FALSE;
</code></pre>

<p>所以，我要自己生成 <em>Token</em> 那就是它的反过程了！</p>

<pre><code>MyValue = "...";            // 必须 10 位长
Subfix = MD5(MyValue + "wuyifan")[0, 6];
Token = encode(MyValue + Subfix);

return Token;
</code></pre>

<p>用代码测试了下，有些生成的 <em>Token</em> 可以发送，有些不行。原来它声音发送的数据还有一点要求，<code>MyValue</code> 必须是 16 进制的字符 0~f，并且第1位是0~7，总的来说，一次只能通过声音传5字节不到的数据。</p>

<pre><code>出于保护的目的，dkey ekey 就不公布出来了，感兴趣的可以私下联系。另外，如果`蛐蛐儿`的开发者认为此
文章不合适也请联系本人删除。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iZJU中浙大黄页的实现]]></title>
    <link href="http://rickytan.cn/blog/2013/06/16/izjuzhong-zhe-da-huang-ye-de-shi-xian/"/>
    <updated>2013-06-16T11:33:00+08:00</updated>
    <id>http://rickytan.cn/blog/2013/06/16/izjuzhong-zhe-da-huang-ye-de-shi-xian</id>
    <content type="html"><![CDATA[<h2>简介</h2>

<p>用过<a href="https://itunes.apple.com/cn/app/izju/id573810521?mt=8">iZJU iOS</a>版的同学应该会注意到，在2.1.1版本之后新增了“浙大黄页”的功能。</p>

<p><img src="/images/screenshot20130616.png" alt="iZJU" /></p>

<p>这个功能是原先“紧急电话”的加强版，细心的同学会知道，所有的电话号码数据来自“浙大电话黄页”网站（<a href="http://zjutel.zju.edu.cn">http://zjutel.zju.edu.cn</a>），如下图：</p>

<p><img src="/images/QQ20130616-1.png" alt="浙大黄页" /></p>

<h2>数据获取</h2>

<p>网站管理员我不熟，他也不会主动给我数据，获取这个唯一的办法就是抓取了。但是网站数据没有一次列全，自己点开哪个就能看到哪个，如何一次性抓到所有数据？人工去点开吧，嗯，一开始我是这么想的，可是后来发现能展开的节点太多了，自己点太蛋疼了。于是就想到了让浏览器自动点。</p>

<p>于是乎花了些时间写了个Chrome 小插件，如果还有节点，点开那个节点链接，否则无动作。
主要代码如下，通过一张小gif 图来判断是否可以展开：</p>

<!--more-->


<p>{% codeblock index.user.js lang:js %}
function open() {</p>

<pre><code>var img = $("font").find("img");
img.each(function(k,v){
    if (v.src.indexOf("w.gif") != -1) {
        var p1 = $(this).parents("tr").children("td").length;
        var p2 = $(this).parents("tr").next().children("td").length;
        if (p1 &gt;= p2) {
            var c = this.parentNode.attributes[0];
            var urlS = c.childNodes[0].textContent;
            var idx = urlS.indexOf("?", 0)
            var url = urlS.substr(idx, urlS.length - idx - 2);
            var a = document.createElement("a");
            a.href = url;
            document.body.appendChild(a);
            a.click();
            return false;
        }
    }
});
</code></pre>

<p>}
window.setTimeout(open, 300);
{% endcodeblock %}</p>

<p>打包为.crx 后<strong><a href="/download/zjutel.crx">安装</a></strong>，在Chrome访问<a href="http://zjutel.zju.edu.cn/tree.php">http://zjutel.zju.edu.cn/tree.php</a>，插件就开始工作了，这时你可以坐下来喝喝咖啡，等它停止。</p>

<p>停止之后，将整个网页下载下来，可以用<code>Vim</code>等文本编辑器用搜索替换的方式去除HTML标签等不必要的信息，最终整理成如下所示文本文件（tree.txt）：</p>

<p>{% codeblock %}
!+ 浙江大学
!!+ 党委正 副书记(秘书)
!!! 党委书记秘书 : 88981739
!!! 邹晓东副书记联系秘书 : 88981457
!!! 郑强副书记联系秘书 : 88981175
!!! 任少波副书记联系秘书 : 88981062
!!! 周谷平 :
!!+ 校长 副校长(秘书)
!!! 杨卫校长秘书 : 88981109
!!! 来茂德副校长联系秘书 : 88981217
&hellip;&hellip;
{% endcodeblock %}</p>

<p>以上文本，既包含了节点信息，又有节点间的层次关系。下面将说明如何处理它让它成为结构化的数据。</p>

<h2>数据处理</h2>

<p>观察上述文本的格式，以“＋”号结尾的都是有子部门的大部门，而没有“＋”的则是有电话信息的叶节点，同时“！”号的个数
表明了它所处的层级。
为了方便处理，抽象出两个数据模型：Node，Number。Node 指所有部门节点，而Number是叶节点的电话信息。可以想见只有叶节点才能有电话信息，但叶节点不一定有电话信息。</p>

<p>建立数据表如下：</p>

<p>{% codeblock lang:sql %}</p>

<p>USE zjutel;</p>

<p>CREATE TABLE IF NOT EXISTS <code>Node</code> (</p>

<pre><code>`id`          INT auto_increment NOT NULL COMMENT '',
`pid`         INT NOT NULL DEFAULT 0 COMMENT '父节点id',
`title`       varchar(128) NOT NULL COMMENT '节点标题',
`has_child`   bool NOT NULL DEFAULT FALSE COMMENT '是否有子节点',
`is_leaf`     bool NOT NULL DEFAULT FALSE COMMENT '是否为叶节点，叶节点一定有电话号码',
`create_date` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',
`update_date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
PRIMARY KEY(`id`),
KEY (`title`)
</code></pre>

<p>)default charset=UTF8 engine=InnoDB,AUTO_INCREMENT=1;</p>

<p>CREATE TABLE IF NOT EXISTS <code>Number</code> (</p>

<pre><code>`id`          INT auto_increment NOT NULL,
`nid`         INT NOT NULL,
`number`      VARCHAR(20) NOT NULL DEFAULT '',
PRIMARY KEY(`id`),
FOREIGN KEY(`nid`) REFERENCES `Node`(`id`) ON DELETE CASCADE,
KEY (`nid`),
KEY (`number`)
</code></pre>

<p>)default charset=UTF8 engine=InnoDB AUTO_INCREMENT=1;</p>

<p>{% endcodeblock %}</p>

<p>然后简单地写了个PHP脚本来处理，并存入数据库。更具体的信息，请访问Github Repo: <a href="https://github.com/rickytan/YellowPage">https://github.com/rickytan/YellowPage</a>，所有源代码都是开放的！zjutel.db 是处理好之后的 <code>Sqlite</code> 数据库，可以直接在手机等中使用。</p>

<p>此电话信息的更多利用价值，有待大家一起挖掘！</p>
]]></content>
  </entry>
  
</feed>
